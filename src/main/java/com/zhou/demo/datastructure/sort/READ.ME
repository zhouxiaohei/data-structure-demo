

当前包下类说明：


InsertSort   插入排序
把n个待排序的元素看成为包含一个元素的有序表和包含N-1个元素无序表，
(使用冒泡排序)-->排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

8w数据 2s  对小规模数据和基本有序的数据效率高


BubbleSort  冒泡排序
1、一共进行n-1次排序
2、每一次排序逐渐减小，每一次得到最大(正序)或最小(倒叙)；最值不需要再次参与排序
80w 耗费太久了 cost 1711s 28.5min！！！    8w数据  13s


SelectSort  选择排序
选择最小/大的放在首位；依次循环；
8w数据  3s   选择N小时排序比冒泡快，对数据量小好


QuickSort   快速排序
https://www.sohu.com/a/246785807_684445   漫谈快速排序
对冒泡排序的改进；使用递归；
思路： 选一个基准元素、将比基准小的放在左边，比基准大的放在右边，一直到左下标和右边下标重合，得到左边比基准小，右边比基准大的一组数据；替换基准元素，然后递归，直到排序成功。

基准元素使用两边的元素比较容易，此时直接用最边上的基准元素替换；
(选最左边做基准就从最右边开始循环遍历，这样左右重合以后，重合点一定是小于基准元素，反之亦然)
好的基准元素可以提高比较的效率，当然不知道那个基准元素更优。

不稳定
8w 33-70ms  80w 160~180ms 800w 1.7s


ShellSort  希尔排序
希尔排序是对插入排序的优化；增加步长的概念，对步长相关的进行插入排序；当步长为1时排序成功；借鉴插入排序对有序数据效率高的特点；
插入排序相当于步长为1的一组进行排序，希尔排序是分成步长为N/2的两组，一直分到步长为1的一组即有序；

8w数据20-30ms！！  80w数据225ms！ 800w数据 2-3s！ 优秀   对中等规模数据有效  不稳定


MergeSort  归并排序
再次递归；需要额外的空间
思路: 是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
8w 21-23ms  80w 150~200ms 800w 1.6~1.9s


 基数排序（桶排序扩展）
  需要额外的空间
  思路： 建立10个桶0-9，针对每个元素从低位到高位进行比较，放入响应桶中；
             直到对最高位的元素们进行排序，自然有序了。



